<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§‡§ø ‡§∏‡§æ‡§Å‡§™-‡§∏‡•Ä‡§¢‡§º‡•Ä ‡§ñ‡•á‡§≤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            min-height: 100vh;
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: auto;
        }
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            padding: 25px;
            max-width: 1200px;
            width: 100%;
            position: relative;
        }
        .game-header {
            text-align: center;
            margin-bottom: 25px;
        }
        .game-title {
            color: #2c3e50;
            font-size: 2.2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .game-subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
            margin-bottom: 15px;
        }
        .player-setup {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            text-align: center;
        }
        .player-count {
            margin-bottom: 15px;
        }
        .player-count label {
            font-weight: bold;
            margin-right: 10px;
            color: #2c3e50;
        }
        .player-count select {
            padding: 8px 15px;
            border: 2px solid #bdc3c7;
            border-radius: 25px;
            font-size: 1em;
            background: white;
        }
        .start-game-btn {
            padding: 12px 25px;
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            margin-left: 15px;
            transition: all 0.3s ease;
        }
        .start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }
        .game-area {
            display: none;
        }
        .game-area.active {
            display: block;
        }
        .players-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }
        .player-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 15px;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            text-align: center;
        }
        .player-card.active {
            border-color: #3498db;
            background: #e3f2fd;
            transform: scale(1.05);
        }
        .player-name {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        .player-position {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        .game-board-container {
            position: relative;
            height: 500px;
            margin-bottom: 25px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 25px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        .dice {
            width: 70px;
            height: 70px;
            background: white;
            border: 3px solid #34495e;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            font-weight: bold;
            color: #34495e;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .dice:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }
        .dice.rolling {
            animation: roll 0.8s ease-in-out;
        }
        @keyframes roll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg); }
        }
        .roll-btn {
            padding: 12px 25px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }
        .roll-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(52, 152, 219, 0.6);
        }
        .roll-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .game-status {
            text-align: center;
            font-size: 1.2em;
            color: #2c3e50;
            margin-bottom: 15px;
            padding: 12px;
            background: #ecf0f1;
            border-radius: 10px;
            border-left: 4px solid #3498db;
        }
        .message-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            z-index: 1000;
            text-align: center;
            display: none;
        }
        .message-popup.show {
            display: block;
            animation: popIn 0.5s ease-out;
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        .message-popup h3 {
            color: #2c3e50;
            margin-bottom: 12px;
            font-size: 1.4em;
        }
        .message-popup p {
            color: #7f8c8d;
            line-height: 1.6;
            margin-bottom: 18px;
        }
        .close-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 18px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .close-btn:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }
        .overlay.show {
            display: block;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            font-size: 0.9em;
        }
        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
        }
        .ladder-color {
            background: linear-gradient(45deg, #3498db, #2980b9);
        }
        .snake-color {
            background: linear-gradient(45deg, #8B4513, #A0522D);
        }
        .awareness-color {
            background: #f1c40f;
        }
        .support-color {
            background: #2ecc71;
        }
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a2a6c;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
        }
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden {
            display: none;
        }
        .restart-btn {
            padding: 10px 20px;
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            margin-left: 15px;
            transition: all 0.3s ease;
        }
        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }
        .progress-container {
            margin-bottom: 20px;
            background: #ecf0f1;
            border-radius: 15px;
            padding: 15px;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #bdc3c7;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9em;
        }
        .game-summary {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .summary-title {
            color: #2c3e50;
            font-size: 1.5em;
            margin-bottom: 15px;
            text-align: center;
        }
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
        }
        .stat-label {
            color: #7f8c8d;
            font-size: 0.9em;
            margin-top: 5px;
        }
        .message-popup.positive {
            border-left: 5px solid #27ae60;
        }
        .message-popup.negative {
            border-left: 5px solid #e74c3c;
        }
        .message-popup.positive h3 {
            color: #2980b9;
        }
        .message-popup.negative h3 {
            color: #e74c3c;
        }
        
        /* Snake hover effects */
        .snake-hover-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .snake-element {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .snake-element:hover {
            transform: scale(1.1);
            filter: brightness(1.2);
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <p>3D ‡§ó‡•á‡§Æ ‡§≤‡•ã‡§° ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...</p>
    </div>
    
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">üêçü™ú 3D ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§‡§ø ‡§∏‡§æ‡§Å‡§™-‡§∏‡•Ä‡§¢‡§º‡•Ä</h1>
            <p class="game-subtitle">3D ‡§Ö‡§®‡•Å‡§≠‡§µ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§‡§ø ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§ú‡§æ‡§®‡•á‡§Ç</p>
        </div>
        
        <div class="player-setup" id="playerSetup">
            <div class="player-count">
                <label for="playerCountSelect">‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•Ä ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ:</label>
                <select id="playerCountSelect">
                    <option value="2">2 ‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä</option>
                    <option value="3">3 ‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä</option>
                    <option value="4">4 ‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä</option>
                </select>
                <button class="start-game-btn" onclick="startGame()">‡§ñ‡•á‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç</button>
            </div>
        </div>
        
        <div class="game-area" id="gameArea">
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                    <div class="progress-text" id="progressText">0%</div>
                </div>
            </div>
            <div class="players-info" id="playersInfo"></div>
            <div class="game-status" id="gameStatus">
                ‡§ñ‡•á‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡§æ‡§∏‡§æ ‡§´‡•á‡§Ç‡§ï‡•á‡§Ç!
            </div>
            <div class="game-board-container" id="gameBoardContainer">
                <div class="snake-hover-overlay" id="snakeHoverOverlay"></div>
            </div>
            <div class="controls">
                <div class="dice" id="dice">üé≤</div>
                <button class="roll-btn" id="rollBtn">‡§™‡§æ‡§∏‡§æ ‡§´‡•á‡§Ç‡§ï‡•á‡§Ç</button>
                <button class="restart-btn" onclick="restartGame()">‡§®‡§Ø‡§æ ‡§ñ‡•á‡§≤</button>
            </div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color ladder-color"></div>
                    <span>‡§∏‡•Ä‡§¢‡§º‡•Ä</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color snake-color"></div>
                    <span>‡§∏‡§æ‡§Å‡§™</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color awareness-color"></div>
                    <span>‡§ú‡§æ‡§ó‡§∞‡•Ç‡§ï‡§§‡§æ</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color support-color"></div>
                    <span>‡§∏‡§π‡§æ‡§Ø‡§§‡§æ</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="overlay" id="overlay"></div>
    <div class="message-popup" id="messagePopup">
        <h3 id="popupTitle"></h3>
        <p id="popupMessage"></p>
        <button class="close-btn" onclick="closePopup()">‡§∏‡§Æ‡§ù ‡§ó‡§Ø‡§æ</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game data
        const awarenessMessages = {
            2: "‡§®‡§∂‡§æ ‡§õ‡•ã‡§°‡§º‡•ã, ‡§ú‡§º‡§ø‡§Ç‡§¶‡§ó‡•Ä ‡§∏‡•á ‡§®‡§æ‡§§‡§æ ‡§ú‡•ã‡§°‡§º‡•ã‡•§",
            9: "‡§ú‡•ã ‡§®‡§∂‡•á ‡§∏‡•á ‡§≤‡§°‡§º‡•á, ‡§µ‡•ã ‡§∏‡§ö‡•ç‡§ö‡§æ ‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä ‡§π‡•à‡•§",
            18: "‡§®‡§∂‡§æ ‡§õ‡•ã‡§°‡§º‡§ï‡§∞ ‡§ñ‡•á‡§≤‡•ã ‡§ú‡§º‡§ø‡§Ç‡§¶‡§ó‡•Ä ‡§ï‡•Ä ‡§Ö‡§∏‡§≤‡•Ä ‡§≤‡•Ç‡§°‡•ã‡•§",
            24: "‡§ñ‡•Å‡§∂‡§π‡§æ‡§≤ ‡§ú‡•Ä‡§µ‡§® ‡§ï‡§æ ‡§∏‡•Ç‡§§‡•ç‡§∞ ‚Äî ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§ ‡§≠‡§æ‡§∞‡§§‡•§",
            36: "‡§è‡§ï ‡§®‡§∂‡§æ, ‡§∏‡•å ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ‡§è‡§Å‡•§ ‡§á‡§∏‡•á ‡§Ü‡§ú ‡§π‡•Ä ‡§õ‡•ã‡§°‡§º‡•á‡§Ç‡•§",
            45: "‡§Ö‡§ö‡•ç‡§õ‡•á ‡§¶‡•ã‡§∏‡•ç‡§§ ‡§µ‡§π‡•Ä ‡§π‡•à‡§Ç, ‡§ú‡•ã ‡§®‡§∂‡•á ‡§∏‡•á ‡§¶‡•Ç‡§∞ ‡§∞‡§ñ‡•á‡§Ç‡•§",
            58: "‡§§‡§æ‡§ï‡§§ ‡§π‡•à ‡§ñ‡•Å‡§¶ ‡§Æ‡•á‡§Ç, ‡§®‡§∂‡•á ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç‡•§",
            63: "‡§∏‡§™‡§®‡•ã‡§Ç ‡§ï‡•Ä ‡§â‡§°‡§º‡§æ‡§® ‡§®‡§∂‡§æ ‡§®‡§π‡•Ä‡§Ç, ‡§∂‡§ø‡§ï‡•ç‡§∑‡§æ ‡§¶‡•á‡§§‡•Ä ‡§π‡•à‡•§",
            77: "‡§ñ‡•á‡§≤, ‡§ï‡§≤‡§æ ‡§î‡§∞ ‡§™‡§¢‡§º‡§æ‡§à ‚Äì ‡§Ø‡§π‡•Ä ‡§π‡•à ‡§Ö‡§∏‡§≤‡•Ä ‡§®‡§∂‡§æ‡•§",
            84: "'‡§®‡§æ' ‡§ï‡§π‡§®‡§æ ‡§∏‡•Ä‡§ñ‡•ã ‚Äî ‡§®‡§∂‡§æ, ‡§¶‡§¨‡§æ‡§µ ‡§î‡§∞ ‡§¨‡•Å‡§∞‡•Ä ‡§∏‡§Ç‡§ó‡§§ ‡§ï‡•ã‡•§"
        };
        
        const supportMessages = {
            5: "Narcotics Control Bureau (NCB) ‚Äî ‡§≠‡§æ‡§∞‡§§ ‡§Æ‡•á‡§Ç ‡§®‡§∂‡•Ä‡§≤‡•Ä ‡§¶‡§µ‡§æ‡§ì‡§Ç ‡§ï‡•á ‡§µ‡§ø‡§∞‡•Å‡§¶‡•ç‡§ß ‡§∏‡§¨‡§∏‡•á ‡§™‡•ç‡§∞‡§Æ‡•Å‡§ñ ‡§∏‡§Ç‡§∏‡•ç‡§•‡§æ‡•§",
            16: "National Drug Dependence Treatment Centre (NDDTC), AIIMS ‚Äî ‡§á‡§≤‡§æ‡§ú ‡§î‡§∞ ‡§™‡•Å‡§®‡§∞‡•ç‡§µ‡§æ‡§∏ ‡§Æ‡•á‡§Ç ‡§Ö‡§ó‡•ç‡§∞‡§£‡•Ä‡•§",
            27: "Ministry of Social Justice and Empowerment ‚Äî ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§‡§ø ‡§Ö‡§≠‡§ø‡§Ø‡§æ‡§® ‡§ï‡•Ä ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§∏‡§Ç‡§∏‡•ç‡§•‡§æ‡•§",
            33: "‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Ø ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§‡§ø ‡§π‡•á‡§≤‡•ç‡§™‡§≤‡§æ‡§á‡§® 14446 ‚Äî ‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§§‡•Å‡§∞‡§Ç‡§§ ‡§ï‡•â‡§≤ ‡§ï‡§∞‡•á‡§Ç‡•§",
            47: "State Anti-Narcotics Task Forces ‚Äî ‡§π‡§∞ ‡§∞‡§æ‡§ú‡•ç‡§Ø ‡§Æ‡•á‡§Ç ‡§®‡§∂‡•á ‡§ï‡•á ‡§ñ‡§ø‡§≤‡§æ‡§´ ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§¨‡§≤ ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§∞‡§§ ‡§π‡•à‡§Ç‡•§",
            52: "‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Ø ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§Æ‡§ø‡§∂‡§® (NHM) ‚Äî ‡§Æ‡§æ‡§®‡§∏‡§ø‡§ï ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§î‡§∞ ‡§™‡•Å‡§®‡§∞‡•ç‡§µ‡§æ‡§∏ ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§",
            66: "Nasha Mukt Bharat Abhiyan ‚Äî ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§ ‡§≠‡§æ‡§∞‡§§ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•á‡§Ç‡§¶‡•ç‡§∞ ‡§∏‡§∞‡§ï‡§æ‡§∞ ‡§ï‡•Ä ‡§¨‡§°‡§º‡•Ä ‡§™‡§π‡§≤‡•§",
            71: "CARA, NGOs ‡§î‡§∞ ‡§∏‡§æ‡§Æ‡•Å‡§¶‡§æ‡§Ø‡§ø‡§ï ‡§∏‡§Æ‡•Ç‡§π ‚Äî ‡§®‡§∂‡§æ ‡§™‡•Ä‡§°‡§º‡§ø‡§§‡•ã‡§Ç ‡§ï‡•ã ‡§™‡•Å‡§®‡§∞‡•ç‡§µ‡§æ‡§∏ ‡§Æ‡•á‡§Ç ‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‡§¶‡•á‡§§‡•á ‡§π‡•à‡§Ç‡•§",
            89: "Youth Red Cross & NSS Volunteers ‚Äî ‡§ú‡§æ‡§ó‡§∞‡•Ç‡§ï‡§§‡§æ ‡§î‡§∞ ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§‡§ø ‡§∂‡§ø‡§µ‡§ø‡§∞‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§",
            96: "Police & Excise Departments ‚Äî ‡§®‡§∂‡•á ‡§ï‡•á ‡§µ‡•ç‡§Ø‡§æ‡§™‡§æ‡§∞ ‡§™‡§∞ ‡§∏‡§ñ‡•ç‡§§ ‡§®‡§ø‡§ó‡§∞‡§æ‡§®‡•Ä ‡§∞‡§ñ‡§§‡•á ‡§π‡•à‡§Ç‡•§"
        };
        
        const snakes = {
            99: 79, 87: 24, 74: 53, 68: 40, 55: 37, 42: 22, 34: 12, 29: 9, 17: 7
        };
        
        const ladders = {
            4: 14, 11: 32, 23: 44, 38: 59, 49: 67, 65: 85, 72: 91, 81: 98
        };
        
        // Asset paths - fallback to colored shapes if assets not found
        const snakeAssets = {
            normal: [
                'assets/snakes/snake1.svg',
                'assets/snakes/snake2.svg',
                'assets/snakes/snake3.svg',
                'assets/snakes/snake4.svg',
                'assets/snakes/snake5.svg',
                'assets/snakes/snake6.svg',
                'assets/snakes/snake7.svg',
                'assets/snakes/snake8.svg',
                'assets/snakes/snake9.svg'
            ],
            hover: [
                'assets/snakes_hover/snake1.svg',
                'assets/snakes_hover/snake2.svg',
                'assets/snakes_hover/snake3.svg',
                'assets/snakes_hover/snake4.svg',
                'assets/snakes_hover/snake5.svg',
                'assets/snakes_hover/snake6.svg',
                'assets/snakes_hover/snake7.svg',
                'assets/snakes_hover/snake8.svg',
                'assets/snakes_hover/snake9.svg'
            ],
            bite: [
                'assets/snake_bite/snake1.svg',
                'assets/snake_bite/snake2.svg',
                'assets/snake_bite/snake3.svg',
                'assets/snake_bite/snake4.svg',
                'assets/snake_bite/snake5.svg',
                'assets/snake_bite/snake6.svg',
                'assets/snake_bite/snake7.svg',
                'assets/snake_bite/snake8.svg',
                'assets/snake_bite/snake9.svg'
            ]
        };
        
        const ladderAsset = 'assets/ladder/ladder_piece.svg';
        
        // Game state
        let players = [];
        let currentPlayer = 0;
        let gameStarted = false;
        let scene, camera, renderer;
        let boardGroup, playerTokens = [];
        let snakeElements = []; // Store snake 3D objects for interaction
        let raycaster, mouse;
        let animationId;
        let gameStats = {
            totalMoves: 0,
            snakesHit: 0,
            laddersUsed: 0,
            awarenessMessages: 0,
            supportMessages: 0,
            startTime: null
        };
        
        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        
        // Asset loading functions
        function loadTexture(path, fallbackColor = 0x8B4513) {
            return new Promise((resolve) => {
                textureLoader.load(
                    path,
                    (texture) => {
                        resolve(texture);
                    },
                    undefined,
                    (error) => {
                        console.warn(`Could not load texture: ${path}, using fallback color`);
                        resolve(null);
                    }
                );
            });
        }
        
        // Initialize Three.js
        function initThreeJS() {
            const container = document.getElementById('gameBoardContainer');
            
            // Clean up existing renderer
            if (renderer) {
                container.removeChild(renderer.domElement);
                renderer.dispose();
            }
            
            // Scene setup  
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 50);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 15, 15);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
        }
        
        function onWindowResize() {
            const container = document.getElementById('gameBoardContainer');
            if (container && camera && renderer) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }
        
        function onMouseClick(event) {
            const container = document.getElementById('gameBoardContainer');
            const rect = container.getBoundingClientRect();
            
            mouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check snake interactions
            const snakeIntersects = raycaster.intersectObjects(snakeElements, true);
            if (snakeIntersects.length > 0) {
                const snakeObject = snakeIntersects[0].object;
                if (snakeObject.userData.snakeData) {
                    handleSnakeClick(snakeObject.userData.snakeData);
                }
            }
            
            if (boardGroup) {
                const intersects = raycaster.intersectObjects(boardGroup.children, true);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.cellNumber) {
                        highlightCell(object.userData.cellNumber);
                    }
                }
            }
        }
        
        function onMouseMove(event) {
            const container = document.getElementById('gameBoardContainer');
            const rect = container.getBoundingClientRect();
            
            mouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Reset all snake hover states
            snakeElements.forEach(snake => {
                if (snake.userData.isHovering) {
                    snake.userData.isHovering = false;
                    resetSnakeTexture(snake);
                }
            });
            
            // Check snake hover
            const snakeIntersects = raycaster.intersectObjects(snakeElements, true);
            if (snakeIntersects.length > 0) {
                const snakeObject = snakeIntersects[0].object;
                if (snakeObject.userData.snakeData && !snakeObject.userData.isHovering) {
                    snakeObject.userData.isHovering = true;
                    showSnakeHover(snakeObject);
                }
            }
        }
        
        function handleSnakeClick(snakeData) {
            showMessage(
                '‡§∏‡§æ‡§Å‡§™ ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä üêç',
                `‡§Ø‡§π ‡§∏‡§æ‡§Å‡§™ ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ${snakeData.start} ‡§∏‡•á ${snakeData.end} ‡§§‡§ï ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§ ‡§®‡§∂‡•á ‡§ï‡•Ä ‡§≤‡§§ ‡§≠‡•Ä ‡§á‡§∏‡•Ä ‡§§‡§∞‡§π ‡§Ü‡§™‡§ï‡•ã ‡§®‡•Ä‡§ö‡•á ‡§≤‡•á ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à‡•§`,
                'negative'
            );
        }
        
        async function showSnakeHover(snakeObject) {
            const snakeData = snakeObject.userData.snakeData;
            const hoverTexture = await loadTexture(snakeAssets.hover[snakeData.index]);
            
            if (hoverTexture && snakeObject.material) {
                snakeObject.material.map = hoverTexture;
                snakeObject.material.needsUpdate = true;
                snakeObject.scale.set(1.1, 1.1, 1.1);
            }
        }
        
        function resetSnakeTexture(snakeObject) {
            const snakeData = snakeObject.userData.snakeData;
            loadTexture(snakeAssets.normal[snakeData.index]).then(texture => {
                if (texture && snakeObject.material) {
                    snakeObject.material.map = texture;
                    snakeObject.material.needsUpdate = true;
                    snakeObject.scale.set(1, 1, 1);
                }
            });
        }
        
        async function showSnakeBite(snakeObject) {
            const snakeData = snakeObject.userData.snakeData;
            const biteTexture = await loadTexture(snakeAssets.bite[snakeData.index]);
            
            if (biteTexture && snakeObject.material) {
                snakeObject.material.map = biteTexture;
                snakeObject.material.needsUpdate = true;
                
                // Add bite animation
                const originalScale = snakeObject.scale.clone();
                snakeObject.scale.set(1.3, 1.3, 1.3);
                
                // Reset after animation
                setTimeout(() => {
                    snakeObject.scale.copy(originalScale);
                    resetSnakeTexture(snakeObject);
                }, 2000);
            }
        }
        
        function createBoard() {
            boardGroup = new THREE.Group();
            snakeElements = [];
            
            // Board base
            const boardGeometry = new THREE.BoxGeometry(12, 0.5, 12);
            const boardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.y = -0.25;
            board.receiveShadow = true;
            boardGroup.add(board);
            
            // Create tiles
            const tileSize = 1;
            const tileGeometry = new THREE.BoxGeometry(tileSize, 0.1, tileSize);
            
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    const cellNumber = getCellNumber(row, col);
                    const isLeftToRight = row % 2 === 0;
                    const x = isLeftToRight ? 
                        (col - 4.5) * tileSize : 
                        (4.5 - col) * tileSize;
                    const z = (4.5 - row) * tileSize;
                    
                    // Determine tile color
                    let tileColor;
                    if (awarenessMessages[cellNumber]) {
                        tileColor = 0xf1c40f; // Yellow for awareness
                    } else if (supportMessages[cellNumber]) {
                        tileColor = 0x2ecc71; // Green for support
                    } else {
                        tileColor = (row + col) % 2 === 0 ? 0xecf0f1 : 0xbdc3c7;
                    }
                    
                    const tileMaterial = new THREE.MeshStandardMaterial({ 
                        color: tileColor,
                        roughness: 0.7
                    });
                    
                    const tile = new THREE.Mesh(tileGeometry, tileMaterial);
                    tile.position.set(x, 0.05, z);
                    tile.castShadow = true;
                    tile.receiveShadow = true;
                    tile.userData.cellNumber = cellNumber;
                    
                    // Add cell number with better visibility
                    const canvas = document.createElement('canvas');
                    canvas.width = 128;
                    canvas.height = 128;
                    const context = canvas.getContext('2d');
                    
                    // Add background circle for better visibility
                    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    context.beginPath();
                    context.arc(64, 64, 50, 0, 2 * Math.PI);
                    context.fill();
                    
                    // Add number
                    context.fillStyle = '#000';
                    context.font = 'bold 48px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(cellNumber, 64, 64);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const numberMaterial = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        transparent: true
                    });
                    
                    const numberGeometry = new THREE.PlaneGeometry(0.6, 0.6);
                    const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                    numberMesh.rotation.x = -Math.PI / 2;
                    numberMesh.position.set(x, 0.06, z);
                    
                    boardGroup.add(tile);
                    boardGroup.add(numberMesh);
                }
            }
            
            // Add snakes with custom assets
            let snakeIndex = 0;
            Object.entries(snakes).forEach(([start, end]) => {
                createSnake(parseInt(start), parseInt(end), snakeIndex);
                snakeIndex++;
            });
            
            // Add ladders with custom assets
            Object.entries(ladders).forEach(([start, end]) => {
                createLadder(parseInt(start), parseInt(end));
            });
            
            // Add side text "‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§ ‡§ó‡§Ç‡§ó‡§æ‡§®‡§ó‡§∞"
            createSideTexts();
            
            scene.add(boardGroup);
        }
        
        function createSideTexts() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.font = 'bold 40px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§ ‡§ó‡§Ç‡§ó‡§æ‡§®‡§ó‡§∞', 256, 64);
            
            const textTexture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ 
                map: textTexture,
                transparent: true
            });
            
            // Left side text
            const leftTextGeometry = new THREE.PlaneGeometry(8, 2);
            const leftText = new THREE.Mesh(leftTextGeometry, textMaterial);
            leftText.position.set(-8, 2, 0);
            leftText.rotation.y = Math.PI / 2;
            boardGroup.add(leftText);
            
            // Right side text
            const rightTextGeometry = new THREE.PlaneGeometry(8, 2);
            const rightText = new THREE.Mesh(rightTextGeometry, textMaterial);
            rightText.position.set(8, 2, 0);
            rightText.rotation.y = -Math.PI / 2;
            boardGroup.add(rightText);
            
            // Front side text
            const frontTextGeometry = new THREE.PlaneGeometry(8, 2);
            const frontText = new THREE.Mesh(frontTextGeometry, textMaterial);
            frontText.position.set(0, 2, -8);
            boardGroup.add(frontText);
            
            // Back side text
            const backTextGeometry = new THREE.PlaneGeometry(8, 2);
            const backText = new THREE.Mesh(backTextGeometry, textMaterial);
            backText.position.set(0, 2, 8);
            backText.rotation.y = Math.PI;
            boardGroup.add(backText);
        }
        
        function getCellNumber(row, col) {
            const isLeftToRight = row % 2 === 0;
            if (isLeftToRight) {
                return 100 - (row * 10) - col;
            } else {
                return 100 - (row * 10) - (9 - col);
            }
        }
        
        function getCellPosition(cellNumber) {
            const row = Math.floor((100 - cellNumber) / 10);
            let col = (100 - cellNumber) % 10;
            const isLeftToRight = row % 2 === 0;
            
            if (!isLeftToRight) {
                col = 9 - col;
            }
            
            const x = (col - 4.5);
            const z = 4.5 - row;
            
            return { x, y: 0.2, z };
        }
        
        async function createSnake(start, end, snakeIndex) {
            const startPos = getCellPosition(start);
            const endPos = getCellPosition(end);
            
            // Load snake texture
            const snakeTexture = await loadTexture(snakeAssets.normal[snakeIndex % snakeAssets.normal.length]);
            
            // Create more realistic snake body with segments
            const segments = 15;
            const segmentRadius = 0.12;
            
            // Create a curved path for the snake
            const midPoint1 = new THREE.Vector3(
                startPos.x + (Math.random() - 0.5) * 3,
                startPos.y + 1 + Math.random() * 0.5,
                startPos.z + (Math.random() - 0.5) * 3
            );
            const midPoint2 = new THREE.Vector3(
                endPos.x + (Math.random() - 0.5) * 3,
                endPos.y + 0.8 + Math.random() * 0.3,
                endPos.z + (Math.random() - 0.5) * 3
            );
            
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(startPos.x, startPos.y + 0.3, startPos.z),
                midPoint1,
                midPoint2,
                new THREE.Vector3(endPos.x, endPos.y + 0.3, endPos.z)
            ]);
            
            // Create snake body with segments
            for (let i = 0; i < segments; i++) {
                const t = i / (segments - 1);
                const position = curve.getPoint(t);
                const radius = segmentRadius * (1 - t * 0.3); // Tapering effect
                
                const segmentGeometry = new THREE.SphereGeometry(radius, 8, 6);
                let segmentMaterial;
                
                if (snakeTexture) {
                    segmentMaterial = new THREE.MeshStandardMaterial({ 
                        map: snakeTexture,
                        roughness: 0.8
                    });
                } else {
                    segmentMaterial = new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color().setHSL(0.12, 0.8, 0.3 + Math.random() * 0.2),
                        roughness: 0.8
                    });
                }
                
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                segment.position.copy(position);
                segment.castShadow = true;
                segment.userData.snakeData = {
                    start: start,
                    end: end,
                    index: snakeIndex % snakeAssets.normal.length,
                    isSnake: true
                };
                segment.userData.isHovering = false;
                
                boardGroup.add(segment);
                snakeElements.push(segment);
            }
            
            // Create realistic snake head
            const headGeometry = new THREE.SphereGeometry(0.18, 12, 8);
            let headMaterial;
            
            if (snakeTexture) {
                headMaterial = new THREE.MeshStandardMaterial({ 
                    map: snakeTexture,
                    roughness: 0.6
                });
            } else {
                headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4a4a4a,
                    roughness: 0.6
                });
            }
            
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.copy(curve.getPoint(0));
            head.position.y += 0.1;
            head.castShadow = true;
            head.userData.snakeData = {
                start: start,
                end: end,
                index: snakeIndex % snakeAssets.normal.length,
                isSnake: true
            };
            head.userData.isHovering = false;
            
            boardGroup.add(head);
            snakeElements.push(head);
            
            // Add realistic snake eyes
            const eyeGeometry = new THREE.SphereGeometry(0.04, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                emissive: 0x440000
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(head.position.x - 0.08, head.position.y + 0.06, head.position.z - 0.12);
            boardGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(head.position.x + 0.08, head.position.y + 0.06, head.position.z - 0.12);
            boardGroup.add(rightEye);
            
            // Add snake tongue
            const tongueGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.15, 4);
            const tongueMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff4444
            });
            
            const tongue = new THREE.Mesh(tongueGeometry, tongueMaterial);
            tongue.position.set(head.position.x, head.position.y, head.position.z - 0.2);
            tongue.rotation.x = Math.PI / 2;
            boardGroup.add(tongue);
        }
        
        async function createLadder(start, end) {
            const startPos = getCellPosition(start);
            const endPos = getCellPosition(end);
            
            // Load ladder texture
            const ladderTexture = await loadTexture(ladderAsset);
            
            const height = Math.sqrt(
                Math.pow(endPos.x - startPos.x, 2) + 
                Math.pow(endPos.y - startPos.y + 2, 2) + 
                Math.pow(endPos.z - startPos.z, 2)
            );
            
            // Calculate the number of ladder pieces needed
            const pieceHeight = 0.5;
            const pieceCount = Math.ceil(height / pieceHeight);
            
            // Calculate center position and rotation
            const centerX = (startPos.x + endPos.x) / 2;
            const centerY = (startPos.y + endPos.y + 2) / 2;
            const centerZ = (startPos.z + endPos.z) / 2;
            
            // Calculate direction vector
            const direction = new THREE.Vector3(
                endPos.x - startPos.x,
                endPos.y - startPos.y + 2,
                endPos.z - startPos.z
            ).normalize();
            
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
            
            if (ladderTexture) {
                // Use custom ladder pieces
                for (let i = 0; i < pieceCount; i++) {
                    const t = i / (pieceCount - 1);
                    const pieceX = startPos.x + (endPos.x - startPos.x) * t;
                    const pieceY = startPos.y + (endPos.y - startPos.y + 2) * t;
                    const pieceZ = startPos.z + (endPos.z - startPos.z) * t;
                    
                    const pieceGeometry = new THREE.PlaneGeometry(0.6, pieceHeight);
                    const pieceMaterial = new THREE.MeshStandardMaterial({ 
                        map: ladderTexture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    
                    const piece = new THREE.Mesh(pieceGeometry, pieceMaterial);
                    piece.position.set(pieceX, pieceY, pieceZ);
                    piece.quaternion.copy(quaternion);
                    piece.castShadow = true;
                    boardGroup.add(piece);
                }
            } else {
                // Fallback to original ladder design
                createFallbackLadder(startPos, endPos, height, centerX, centerY, centerZ, quaternion);
            }
        }
        
        function createFallbackLadder(startPos, endPos, height, centerX, centerY, centerZ, quaternion) {
            // Create ladder sides
            const sideGeometry = new THREE.CylinderGeometry(0.04, 0.04, height, 8);
            const ladderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3498db,
                roughness: 0.6
            });
            
            // Create left side
            const leftSide = new THREE.Mesh(sideGeometry, ladderMaterial);
            leftSide.position.set(centerX - 0.15, centerY, centerZ);
            leftSide.quaternion.copy(quaternion);
            leftSide.castShadow = true;
            boardGroup.add(leftSide);
            
            // Create right side
            const rightSide = new THREE.Mesh(sideGeometry, ladderMaterial);
            rightSide.position.set(centerX + 0.15, centerY, centerZ);
            rightSide.quaternion.copy(quaternion);
            rightSide.castShadow = true;
            boardGroup.add(rightSide);
            
            // Create rungs
            const rungGeometry = new THREE.CylinderGeometry(0.025, 0.025, 0.35, 8);
            const rungMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2980b9,
                roughness: 0.6
            });
            
            const rungCount = Math.max(3, Math.floor(height / 0.5));
            for (let i = 1; i <= rungCount; i++) {
                const t = i / (rungCount + 1);
                const rungX = startPos.x + (endPos.x - startPos.x) * t;
                const rungY = startPos.y + (endPos.y - startPos.y + 2) * t;
                const rungZ = startPos.z + (endPos.z - startPos.z) * t;
                
                const rung = new THREE.Mesh(rungGeometry, rungMaterial);
                rung.position.set(rungX, rungY, rungZ);
                rung.rotation.z = Math.PI / 2;
                rung.castShadow = true;
                boardGroup.add(rung);
            }
        }
        
        function createPlayerTokens() {
            // Clear existing tokens
            playerTokens.forEach(token => {
                scene.remove(token);
            });
            playerTokens = [];
            
            const colors = [0xe74c3c, 0x3498db, 0x2ecc71, 0xf39c12];
            const startPosition = getCellPosition(1);
            
            players.forEach((player, index) => {
                const geometry = new THREE.CylinderGeometry(0.25, 0.25, 0.4, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: colors[index],
                    roughness: 0.3,
                    metalness: 0.7
                });
                
                const token = new THREE.Mesh(geometry, material);
                
                // Position tokens side by side if multiple players on same cell
                const offset = (index - (players.length - 1) / 2) * 0.3;
                token.position.set(
                    startPosition.x + offset,
                    startPosition.y + 0.2,
                    startPosition.z
                );
                
                token.castShadow = true;
                token.userData.playerId = index;
                
                scene.add(token);
                playerTokens.push(token);
            });
        }
        
        function movePlayerToken(playerIndex, targetCell) {
            const token = playerTokens[playerIndex];
            const targetPosition = getCellPosition(targetCell);
            
            // Adjust position if multiple players on same cell
            const playersOnCell = players.filter(p => p.position === targetCell);
            const playerIndexOnCell = playersOnCell.findIndex(p => p.id === players[playerIndex].id);
            const offset = (playerIndexOnCell - (playersOnCell.length - 1) / 2) * 0.3;
            
            targetPosition.x += offset;
            targetPosition.y = 0.4;
            
            // Animate movement
            const startPos = token.position.clone();
            const startTime = Date.now();
            const duration = 1000;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth movement
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                // Add arc to movement
                const currentPos = new THREE.Vector3().lerpVectors(startPos, targetPosition, easeProgress);
                currentPos.y += Math.sin(easeProgress * Math.PI) * 0.5;
                
                token.position.copy(currentPos);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    token.position.copy(targetPosition);
                }
            }
            
            animate();
        }
        
        function highlightCell(cellNumber) {
            // Reset all tiles
            boardGroup.children.forEach(child => {
                if (child.userData.cellNumber && child.material) {
                    child.material.emissive = new THREE.Color(0x000000);
                }
            });
            
            // Highlight the selected cell
            boardGroup.children.forEach(child => {
                if (child.userData.cellNumber === cellNumber && child.material) {
                    child.material.emissive = new THREE.Color(0x444444);
                }
            });
        }
        
        function updateProgressBar() {
            const maxPosition = Math.max(...players.map(p => p.position));
            const progress = (maxPosition / 100) * 100;
            
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('progressText').textContent = Math.round(progress) + '%';
        }
        
        function showGameSummary(winner) {
            const gameTime = Math.round((Date.now() - gameStats.startTime) / 1000);
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            
            const summaryHTML = `
                <div class="game-summary">
                    <h2 class="summary-title">üéâ ‡§ñ‡•á‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ - ${winner.name} ‡§ï‡•Ä ‡§ú‡•Ä‡§§! üéâ</h2>
                    <div class="summary-stats">
                        <div class="stat-card">
                            <div class="stat-number">${gameTime}</div>
                            <div class="stat-label">‡§ï‡•Å‡§≤ ‡§∏‡§Æ‡§Ø (‡§∏‡•á‡§ï‡§Ç‡§°)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${gameStats.totalMoves}</div>
                            <div class="stat-label">‡§ï‡•Å‡§≤ ‡§ö‡§æ‡§≤‡•á‡§Ç</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${gameStats.snakesHit}</div>
                            <div class="stat-label">‡§∏‡§æ‡§Å‡§™ ‡§Æ‡§ø‡§≤‡•á</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${gameStats.laddersUsed}</div>
                            <div class="stat-label">‡§∏‡•Ä‡§¢‡§º‡•Ä ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${gameStats.awarenessMessages}</div>
                            <div class="stat-label">‡§ú‡§æ‡§ó‡§∞‡•Ç‡§ï‡§§‡§æ ‡§∏‡§Ç‡§¶‡•á‡§∂</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${gameStats.supportMessages}</div>
                            <div class="stat-label">‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‡§∏‡§Ç‡§¶‡•á‡§∂</div>
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <p style="font-size: 1.1em; color: #2c3e50;">
                            ‡§ñ‡•á‡§≤ ‡§ï‡§æ ‡§∏‡§Æ‡§Ø: ${minutes} ‡§Æ‡§ø‡§®‡§ü ${seconds} ‡§∏‡•á‡§ï‡§Ç‡§°<br>
                            ‡§µ‡§ø‡§ú‡•á‡§§‡§æ ‡§ï‡•Ä ‡§ï‡•Å‡§≤ ‡§ö‡§æ‡§≤‡•á‡§Ç: ${winner.moves}<br>
                            <strong style="color: #27ae60;">‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§ ‡§≠‡§æ‡§∞‡§§ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ü‡§™‡§ï‡§æ ‡§Ø‡•ã‡§ó‡§¶‡§æ‡§® ‡§∏‡§∞‡§æ‡§π‡§®‡•Ä‡§Ø ‡§π‡•à!</strong>
                        </p>
                    </div>
                </div>
            `;
            
            // Insert summary before controls
            const controls = document.querySelector('.controls');
            controls.insertAdjacentHTML('beforebegin', summaryHTML);
        }
        
        function startGame() {
            const playerCount = parseInt(document.getElementById('playerCountSelect').value);
            const playerNames = ['‡§≤‡§æ‡§≤ ‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä', '‡§®‡•Ä‡§≤‡§æ ‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä', '‡§π‡§∞‡§æ ‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä', '‡§™‡•Ä‡§≤‡§æ ‡§ñ‡§ø‡§≤‡§æ‡§°‡§º‡•Ä'];
            
            players = [];
            currentPlayer = 0;
            
            // Reset game stats
            gameStats = {
                totalMoves: 0,
                snakesHit: 0,
                laddersUsed: 0,
                awarenessMessages: 0,
                supportMessages: 0,
                startTime: Date.now()
            };
            
            for (let i = 0; i < playerCount; i++) {
                players.push({
                    id: i + 1,
                    name: playerNames[i],
                    position: 1,
                    color: `player-${i + 1}`,
                    moves: 0
                });
            }
            
            document.getElementById('playerSetup').style.display = 'none';
            document.getElementById('gameArea').classList.add('active');
            
            initThreeJS();
            createBoard();
            createPlayerTokens();
            createPlayerInfo();
            updateGameStatus();
            updateProgressBar();
            gameStarted = true;
            
            // Start animation loop
            startAnimationLoop();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
            }, 1000);
        }
        
        function restartGame() {
            // Stop animation loop
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Clean up scene
            if (scene) {
                while(scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
            }
            
            // Remove game summary if exists
            const existingSummary = document.querySelector('.game-summary');
            if (existingSummary) {
                existingSummary.remove();
            }
            
            // Reset game state
            players = [];
            currentPlayer = 0;
            gameStarted = false;
            playerTokens = [];
            snakeElements = [];
            gameStats = {
                totalMoves: 0,
                snakesHit: 0,
                laddersUsed: 0,
                awarenessMessages: 0,
                supportMessages: 0,
                startTime: null
            };
            
            // Reset progress bar
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = '0%';
            
            // Show setup screen
            document.getElementById('gameArea').classList.remove('active');
            document.getElementById('playerSetup').style.display = 'block';
            
            // Reset dice
            document.getElementById('dice').textContent = 'üé≤';
            document.getElementById('rollBtn').disabled = false;
        }
        
        function createPlayerInfo() {
            const playersInfo = document.getElementById('playersInfo');
            playersInfo.innerHTML = '';
            
            players.forEach((player, index) => {
                const playerCard = document.createElement('div');
                playerCard.className = `player-card ${index === currentPlayer ? 'active' : ''}`;
                playerCard.id = `player-card-${index}`;
                playerCard.innerHTML = `
                    <div class="player-name" style="color: ${getPlayerColor(player.color)}">${player.name}</div>
                    <div class="player-position">‡§∏‡•ç‡§•‡§ø‡§§‡§ø: ${player.position}</div>
                `;
                playersInfo.appendChild(playerCard);
            });
        }
        
        function updatePlayerInfo() {
            players.forEach((player, index) => {
                const card = document.getElementById(`player-card-${index}`);
                if (card) {
                    card.className = `player-card ${index === currentPlayer ? 'active' : ''}`;
                    card.querySelector('.player-position').textContent = `‡§∏‡•ç‡§•‡§ø‡§§‡§ø: ${player.position}`;
                }
            });
        }
        
        function getPlayerColor(colorClass) {
            const colors = {
                'player-1': '#e74c3c',
                'player-2': '#3498db',
                'player-3': '#2ecc71',
                'player-4': '#f39c12'
            };
            return colors[colorClass] || '#2c3e50';
        }
        
        function showMessage(title, message, type = 'neutral') {
            document.getElementById('popupTitle').textContent = title;
            document.getElementById('popupMessage').textContent = message;
            
            const popup = document.getElementById('messagePopup');
            popup.className = 'message-popup show';
            
            // Add color coding based on message type
            if (type === 'positive') {
                popup.classList.add('positive');
            } else if (type === 'negative') {
                popup.classList.add('negative');
            }
            
            document.getElementById('overlay').classList.add('show');
        }
        
        function closePopup() {
            const popup = document.getElementById('messagePopup');
            popup.classList.remove('show', 'positive', 'negative');
            document.getElementById('overlay').classList.remove('show');
        }
        
        function playSound(type) {
            // Create audio context for sound effects
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Different frequencies for different events
                switch(type) {
                    case 'snake':
                        oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.5);
                        break;
                    case 'ladder':
                        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.3);
                        break;
                    case 'awareness':
                    case 'support':
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                        break;
                }
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.log("Audio not supported:", e);
            }
        }
        
        function rollDice() {
            if (!gameStarted) return;
            
            const dice = document.getElementById('dice');
            const rollBtn = document.getElementById('rollBtn');
            
            rollBtn.disabled = true;
            dice.classList.add('rolling');
            
            let rollCount = 0;
            const rollInterval = setInterval(() => {
                dice.textContent = Math.floor(Math.random() * 6) + 1;
                rollCount++;
                
                if (rollCount > 8) {
                    clearInterval(rollInterval);
                    const finalRoll = Math.floor(Math.random() * 6) + 1;
                    dice.textContent = finalRoll;
                    dice.classList.remove('rolling');
                    
                    setTimeout(() => {
                        movePlayer(finalRoll);
                        rollBtn.disabled = false;
                    }, 500);
                }
            }, 100);
        }
        
        function movePlayer(steps) {
            const player = players[currentPlayer];
            let newPosition = Math.min(player.position + steps, 100);
            
            // Can only win by exact count
            if (player.position + steps > 100) {
                showMessage('‡§¨‡§π‡•Å‡§§ ‡§ú‡•ç‡§Ø‡§æ‡§¶‡§æ!', `${player.name} ‡§ï‡•ã ${100 - player.position} ‡§ï‡•Ä ‡§ú‡§∞‡•Ç‡§∞‡§§ ‡§π‡•à, ‡§≤‡•á‡§ï‡§ø‡§® ${steps} ‡§Ü‡§Ø‡§æ‡•§ ‡§´‡§ø‡§∞ ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç!`, 'neutral');
                nextPlayer(steps);
                return;
            }
            
            player.position = newPosition;
            player.moves++;
            gameStats.totalMoves++;
            
            movePlayerToken(currentPlayer, newPosition);
            updatePlayerInfo();
            updateGameStatus();
            updateProgressBar();
            
            // Check for win condition
            if (player.position === 100) {
                setTimeout(() => {
                    showMessage('‡§¨‡§ß‡§æ‡§à ‡§π‡•ã! üéâ', `${player.name} ‡§®‡•á ‡§ñ‡•á‡§≤ ‡§ú‡•Ä‡§§ ‡§≤‡§ø‡§Ø‡§æ! ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§ ‡§ú‡•Ä‡§µ‡§® ‡§ï‡•Ä ‡§ì‡§∞ ‡§Ø‡§π ‡§è‡§ï ‡§¨‡§°‡§º‡§æ ‡§ï‡§¶‡§Æ ‡§π‡•à‡•§`, 'positive');
                    gameStarted = false;
                    showGameSummary(player);
                }, 1000);
                return;
            }
            
            // Check for snake, ladder, or special cells after a delay
            setTimeout(() => {
                checkSpecialCells(player, steps);
            }, 1000);
        }
        
        function checkSpecialCells(player, steps) {
            if (snakes[player.position]) {
                playSound('snake');
                gameStats.snakesHit++;
                const oldPosition = player.position;
                player.position = snakes[player.position];
                
                // Find and animate the snake that bit the player
                const biteSnake = snakeElements.find(snake => 
                    snake.userData.snakeData && 
                    snake.userData.snakeData.start === oldPosition
                );
                
                if (biteSnake) {
                    showSnakeBite(biteSnake);
                }
                
                movePlayerToken(currentPlayer, player.position);
                showMessage('‡§∏‡§æ‡§Å‡§™! üêç', `‡§ì‡§π ‡§®‡§π‡•Ä‡§Ç! ${player.name} ‡§∏‡§æ‡§Å‡§™ ‡§ï‡•á ‡§Æ‡•Å‡§Å‡§π ‡§Æ‡•á‡§Ç ‡§´‡§Å‡§∏ ‡§ó‡§è ‡§î‡§∞ ${oldPosition} ‡§∏‡•á ${player.position} ‡§™‡§∞ ‡§Ü ‡§ó‡§è‡•§ ‡§®‡§∂‡§æ ‡§≠‡•Ä ‡§ê‡§∏‡•á ‡§π‡•Ä ‡§Ü‡§™‡§ï‡•ã ‡§®‡•Ä‡§ö‡•á ‡§≤‡•á ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§`, 'negative');
                updatePlayerInfo();
                updateProgressBar();
            } else if (ladders[player.position]) {
                playSound('ladder');
                gameStats.laddersUsed++;
                const oldPosition = player.position;
                player.position = ladders[player.position];
                movePlayerToken(currentPlayer, player.position);
                showMessage('‡§∏‡•Ä‡§¢‡§º‡•Ä! ü™ú', `‡§µ‡§æ‡§π! ${player.name} ‡§®‡•á ‡§∏‡•Ä‡§¢‡§º‡•Ä ‡§™‡§ï‡§°‡§º ‡§≤‡•Ä ‡§î‡§∞ ${oldPosition} ‡§∏‡•á ${player.position} ‡§™‡§∞ ‡§ö‡§¢‡§º ‡§ó‡§è‡•§ ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§‡§ø ‡§ï‡•á ‡§∞‡§æ‡§∏‡•ç‡§§‡•á ‡§™‡§∞ ‡§Ø‡§π ‡§è‡§ï ‡§Ö‡§ö‡•ç‡§õ‡§æ ‡§ï‡§¶‡§Æ ‡§π‡•à‡•§`, 'positive');
                updatePlayerInfo();
                updateProgressBar();
                
                // Check for win after ladder
                if (player.position === 100) {
                    setTimeout(() => {
                        showMessage('‡§¨‡§ß‡§æ‡§à ‡§π‡•ã! üéâ', `${player.name} ‡§®‡•á ‡§∏‡•Ä‡§¢‡§º‡•Ä ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ñ‡•á‡§≤ ‡§ú‡•Ä‡§§ ‡§≤‡§ø‡§Ø‡§æ! ‡§®‡§∂‡§æ ‡§Æ‡•Å‡§ï‡•ç‡§§ ‡§ú‡•Ä‡§µ‡§® ‡§ï‡•Ä ‡§ì‡§∞ ‡§Ø‡§π ‡§è‡§ï ‡§¨‡§°‡§º‡§æ ‡§ï‡§¶‡§Æ ‡§π‡•à‡•§`, 'positive');
                        gameStarted = false;
                        showGameSummary(player);
                    }, 1000);
                    return;
                }
            } else if (awarenessMessages[player.position]) {
                playSound('awareness');
                gameStats.awarenessMessages++;
                showMessage('‡§ú‡§æ‡§ó‡§∞‡•Ç‡§ï‡§§‡§æ ‡§∏‡§Ç‡§¶‡•á‡§∂ üí°', awarenessMessages[player.position], 'positive');
            } else if (supportMessages[player.position]) {
                playSound('support');
                gameStats.supportMessages++;
                showMessage('‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‡§∏‡§Ç‡§∏‡§æ‡§ß‡§® ü§ù', supportMessages[player.position], 'positive');
            }
            
            nextPlayer(steps);
        }
        
        function nextPlayer(steps) {
            // Move to next player if not a 6
            if (steps !== 6) {
                currentPlayer = (currentPlayer + 1) % players.length;
                updateGameStatus();
                updatePlayerInfo();
            } else {
                showMessage('‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ö‡§≤‡•á‡§Ç! üé≤', `${players[currentPlayer].name} ‡§ï‡•ã 6 ‡§Ü‡§Ø‡§æ ‡§π‡•à! ‡§â‡§®‡•ç‡§π‡•á‡§Ç ‡§è‡§ï ‡§î‡§∞ ‡§Æ‡•å‡§ï‡§æ ‡§Æ‡§ø‡§≤‡§§‡§æ ‡§π‡•à‡•§`, 'positive');
            }
        }
        
        function updateGameStatus() {
            const statusElement = document.getElementById('gameStatus');
            const current = players[currentPlayer];
            statusElement.textContent = `${current.name} ‡§ï‡•Ä ‡§¨‡§æ‡§∞‡•Ä ‡§π‡•à (‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡•ç‡§•‡§ø‡§§‡§ø: ${current.position})`;
        }
        
        function startAnimationLoop() {
            function animate() {
                if (!gameStarted && animationId) {
                    cancelAnimationFrame(animationId);
                    return;
                }
                
                animationId = requestAnimationFrame(animate);
                
                if (renderer && scene && camera) {
                    // Gentle camera rotation for dynamic view (slower speed)
                    const time = Date.now() * 0.0001; // Reduced from 0.0003 to 0.0001 for slower rotation
                    const radius = 15;
                    camera.position.x = Math.sin(time) * radius;
                    camera.position.z = Math.cos(time) * radius;
                    camera.lookAt(0, 0, 0);
                    
                    renderer.render(scene, camera);
                }
            }
            animate();
        }
        
        // Event listeners
        document.getElementById('rollBtn').addEventListener('click', rollDice);
        document.getElementById('dice').addEventListener('click', rollDice);
        
        // Close popup on overlay click
        document.getElementById('overlay').addEventListener('click', closePopup);
        
        // Initialize the game
        function init() {
            // Hide loading screen initially
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
            }, 500);
        }
        
        // Start the game when page loads
        window.onload = init;
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });
    </script>
</body>
</html>